# 2.2.2 Cycle 2: Storing Data

## Design

In the previous cycle, I produced a program that was able to collect data from sensors and upload these values to the particle cloud. In this section, I will now focus on how this data can be processed and stored, to make it accessible to my weather application.

In this cycle I aim to learn how to use a text-based database (MongoDB). I will then produce a program that uploads readings from the weather station to the database so that it can be accessed in later cycles.

### Objectives

* [x] Learn how to use MongoDB
* [x] Design a program that uploads data to MongoDB
* [x] Connect Argon to MQTT broker
* [x] Connect MongoDB program to broker
* [x] Use database to record data from the weather station
* [ ] Data processing

### Usability Features

Ensuring that this database works correctly is vital to my project because it will allow my app to connect to the weather station and show trends in the environment over time. The program should automatically upload and store data without any input from the user. To improve usability for the stakeholder, the data recorded on MongoDB must be accurate and valid, to prevent any incorrect data trends or problems in later development cycles.

### Tests I need to conduct

| ID  | Test                                       | Description                                                                                                                                                                                                                                                               | Pass Criteria                                                                                                                                                            |
| --- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 2.1 | Design basic program to setup the database | In this test, I will learn how to interact with mongoDB                                                                                                                                                                                                                   | As well as connecting to the database, I will test a program that is able to perform several tasks, including inserting, updating, deleting and finding documents.       |
| 2.2 | Set up a remote MQTT broker                | In this section, I will connect the particle argon to a broker (such as HiveMQ or MQTTHQ).                                                                                                                                                                                | I will need to succesfully design a program that is capable of connecting to the MQTT broker. The data collected by the weather station should be recived by the client. |
| 2.3 | Setup database with weather station        | In this section, I will use the data from my weather station program and publish it to the broker, so that it can then be recorded on my database                                                                                                                         | The python program should be able to subscribe to the MQTT broker and save this data to MongoDB.                                                                         |
| 2.4 | Data processing and validation             | While this section is not essential to the functionality of my project, it will help improve usability and prevent errors. I will adapt the program to ensure that data from the weather station is recorded at regular intervals, and only valid/accurate data is stored | The program should be able to flag anomalous readings/incorrect data and not include it on the database.                                                                 |

### Data Structures

| Structure name | Structure type | Description |
| -------------- | -------------- | ----------- |
|                |                |             |
|                |                |             |
|                |                |             |

### Development

### 2.1

In the first part of this cycle, I am going to learn how to use MongoDB (a document-based database), including adding a post, making changes and retrieving data. I have decided to use phython to interact with MongoDB.

#### Inserting documents into the database

I started by writing a basic program that can interact with my database.

```python
import pymongo
from pymongo import MongoClient

client= MongoClient("mongodb+srv://lrosesmith23:<password>@mystation.uoil79h.mongodb.net/?retryWrites=true&w=majority") #selects client

db = client.weatherStationData #Selects database

collection = db.weather #Select collection in database

#Insert a post into a database
post = {"_id": 1, "date": "21/06/23", "temperature": 27, "airquality": "fresh air"} #Sample data

collection.insert_one(post)
```

Using pymongo, I was successfully able to interact with my database and inset a post. The results of this program can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 11.21.38.png" alt=""><figcaption></figcaption></figure>

If I don't assign an ID to the document, one is automatically generated when the post is inserted.&#x20;

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 11.33.52.png" alt=""><figcaption></figcaption></figure>

After inserting one document into my database, I then decided to adapt my database to insert multiple posts at once.

```python
#4 document examples
post1 = {"_id": 2, "date": "21/06/23", "temperature": 19, "airquality": "fresh air"} 
post2 = {"_id": 3, "date": "21/06/23", "temperature": 21, "airquality": "low polution"}
post3 = {"_id": 4, "date": "21/06/23", "temperature": 27, "airquality": "hight polution"}
post4 = {"_id": 5, "date": "21/06/23", "temperature": 22, "airquality": "danger"}

#Insert many documents into the collection
collection.insert_many([post1, post2, post3, post4])
```

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 11.47.16.png" alt=""><figcaption></figcaption></figure>

#### Updating documents

Within my solution, I may need to make changes to the data stored in my weather station. I used the .update\_one() and .update\_many() methods to setup new fields.

```python
#UPDATE DOCUMENT

#Adding a new field to one document
collection.update_one({"_id":1}, {"$set": {"humidity": 45}})

#Adding a new field to multiple documents
collection.update_many({"temperature": 27}, {"$set": {"pressure": 10000}})

#Updating an old field
collection.update_one({"_id": 5}, {"$set": {"airquality": "fresh air"}})
```

The changes made to my database after running this program can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 13.29.36.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 13.30.59.png" alt=""><figcaption></figcaption></figure>

This program made the expected alterations to my database and therefore passed the test.

#### Deleting documents

Throughout my project, I will need to be able to delete old documents or remove incorrect and inaccurate data. This can be done using the .delete\_one() or .delete\_many() method.

<pre class="language-python"><code class="lang-python"># Delete one item 
<strong>collection.delete_one({"_id":1})
</strong>
# Delete multiple posts
collection.delete_many({"temperature":27})

# Deletes all documents in the database
collection.delete_many({})
</code></pre>

I tested each of these lines of code individually. The first test successfully removed the document with and ID of 1 from my database. After running the second test, all lines of code that has a temperature of 27 where removed. After running the final test, all posts in the database where removed, leaving me with an empty database.

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 13.04.12.png" alt=""><figcaption></figcaption></figure>

#### Finding documents

When retrieving data from my database, I will need to use a query to search for specific attributes in documents. For instance, I may need to search for dates, times and weather events. After adding back the origonal posts to the database, I used the code below to search for documents in my database.



```python
#FINDING DOCUMENTS

# Test 1 - Searching for a post by its ID
findings1 = collection.find_one({"_id": 1})
print("Test 1: " + str(findings1))

# Test 2 - Looking for multiple posts with the same attributes
findings2 = collection.find({"temperature": 27})
print("\nTest 2:")

for doc in findings2:
    print(doc)

# Test 3 - Search by multiple fields
findings3 = collection.find({"_id": 1, "temperature": 27})
print("\nTest 3: ")

for doc in findings3:
    print(doc)

# Test 4 - No criteria
findings4 = collection.find({})
print("\nTest 4:")

for doc in findings4:
    print(doc)
```

Outputs from the terminal:

<figure><img src="../.gitbook/assets/Screenshot 2023-06-21 at 12.22.14.png" alt=""><figcaption></figcaption></figure>

In the first test, I used the .find\_one() method to search for a particular ID, which printed out one document as expected. The second test searched for multiple posts with the same value (27) for temperature. As expected, this returned 3 documents, so the test passed. Next, I tried searching using multiple attributes, ID and temperature. Finally, in test 4 I used the .find() method without any conditions, which returned all the documents in my database.

### 2.2

In tests [2.2](2.2.2-cycle-2-storing-data.md#2.2) and [2.3](2.2.2-cycle-2-storing-data.md#2.3), I am going to design a program that uploads weather documents to this database, simulating the readings from my weather station. In [Cycle 1: Data Collection](cycle-1.md), I collected data on temperature, humidity, pressure, altitude, air quality, air pressure, dust concentration, light and sound from sensors. These fields will therefore have to be included in the documents. Addititionally, so that I can monitor weather conditions in my solution, I need to record the data and time these readings were taken. Readings must be inserted into the database at regular intervals, and I must also consider the capacity of my database when keeping data over long periods of time.

### Pseudocode

<pre><code>def connectMongo:
<strong>    // Connect to mongo client
</strong>    client = mongoClient("")
    db = client.weatherStationData #Selects database
    collection = db.weather #Select collection in database
</code></pre>

However, before I can upload data to the database, the data on the particle Argon needs to be accessed by the python program. To do this, used the MQTT protocol to connect to a broker (e.g. HiveMQ) and then saved the data to MongoDB. The diagram below summarises how this will work.

<figure><img src="../.gitbook/assets/Screenshot 2023-06-22 at 20.03.10.png" alt=""><figcaption></figcaption></figure>

#### Setting up a remote MQTT broker

Before I designed a program to publish data on the particle Argon, I first needed to test the connection with the broker in the terminal.

```
mosquitto_sub -h 683186625ce24d4aa43825f47a959ede.s2.eu.hivemq.cloud -p 8883 -u lucyargon22 -P <mypassword> -t lucystopoc
```

In a different terminal, I then published a test message to the MQTT broker by running the following commands.

```
mosquitto_pub -h 683186625ce24d4aa43825f47a959ede.s2.eu.hivemq.cloud -p 8883 -u lucyargon22 -P <mypassword> -t lucystopoc -m "Hello World"
mosquitto_pub -h 683186625ce24d4aa43825f47a959ede.s2.eu.hivemq.cloud -p 8883 -u lucyargon22 -P <mypassword> -t lucystopoc -m "Testing, testing..."
```

<figure><img src="../.gitbook/assets/Screenshot 2023-06-22 at 19.31.08.png" alt=""><figcaption></figcaption></figure>

As expected, I then recieved both messages in the first terminal, confirming that the MQTT broker was working correctly.

#### Connecting to broker via the Argon

The next step in this cycle is connecting the particle Argon to a broker. However, when designing my program, I had some issues with using HiveMQ to connect to the particle argon. Instead, I decided to use MQTTHQ as a my client as it didn't require any additional authentication which could cause issues when connected. I started by adding the following code to my origonal data collection program from[ cycle 1.](cycle-1.md)

<pre class="language-cpp"><code class="lang-cpp">// MQTT BROKER CONNECTION

//Including MQTT library
#include "MQTT.h"

String clientID = "mrargon"

//Set up MQTT broker

// Assign server to MQTT client
char server[ ] = "public.mqtthq.com";

// Port = 1883
MQTT client(server, 1883, callback); 

// Define a callback function to initialize the MQTT client.
void callback(char* topic, byte* payload, unsigned int length) {
}

// Procedure that published data to MQTT client
void mqtt_publish(char *pubdata) {
  client.publish("weather/station/data",pubdata);
}

// Function that reconects particle Argon device to the MQTT client

void reconnect(){
  Particle.publish("Attempting MQTT connection");
        
  // Connect to the HiveMQ MQTT broker.
  
  int connected = client.connect(clientId);
  //Connected will have the value 0 if connected to the client
  if (!connected)  { 
    // Track the connection with particle console.
    Particle.publish("Connected to MQTT client");
  } 
  else {
    String connectionCode = "Connection return code: " + (String)connected;
    Particle.publish(connectionCode);
    Particle.publish("Failed to connect. Trying to reconnect in 3 seconds");
    //Delays for 3 seconds before trying to reconnect
    delay(3000);
  } 
}

//Code added to setup function
void setup(){
<strong>  client.connect(clientId);
</strong><strong>  
</strong><strong>  //Another test point to ensure device is connected to MQTT
</strong>  if (client.isConnected()) {
    Particle.publish("Device is not connected");
  }
}

//Code added to loop function
void loop(){
  // If MQTT client is not connected then reconnect.
  if (!client.isConnected()) {
    Particle.publish("Device not connecting. Trying to reconnect");
    reconnect();
  } else {
    Particle.publish("Device online and publishing data to the cloud");
  }
    
  //Calls function to publish weather data to MQTT client
  mqtt_publish(jw.getBuffer());
  
  //Publishes data to particle console
  Particle.publish("weatherStationData", jw.getBuffer(), PRIVATE);
}

</code></pre>

I then subscribed to the broker from the visual studio code terminal and through the MQTTHQ website to ensure the program was working correctly. This produced the expected results, as can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-06-26 at 18.53.54.png" alt=""><figcaption><p>Output from terminal</p></figcaption></figure>

<figure><img src="../.gitbook/assets/Screenshot 2023-06-26 at 18.56.58.png" alt=""><figcaption></figcaption></figure>

### 2.3

Previously, I adapted the program in the first cycle to upload data to a MQTT client. In this development cycle, I am going to focus on combining section [2.1 ](2.2.2-cycle-2-storing-data.md#2.1)and [2.2](2.2.2-cycle-2-storing-data.md#2.2) to design a system that connects to the weather station and uploads this data to the database.&#x20;

#### Establishing a connection with the broker

In this section, I am going to start by setting up a basic python program that connects to both mobgoDB and my MQTT broker. The code for this has been outlined below.

```python
import pymongo
from pymongo import MongoClient

client= MongoClient("mongodb+srv://lrosesmith23:<password>@mystation.uoil79h.mongodb.net/?retryWrites=true&w=majority") #selects client

db = client.weatherStationData #Selects database

collection = db.weather #Select collection in database

# Setting up connection with the MQTT broker

import paho.mqtt.client as mqtt

myBroker = "public.mqtthq.com"
client = mqtt.Client("Processing program")
client.connect(myBroker) #Connect to broker
```

#### Subscribing to the MQTT broker

The next stage is to subscribe the the MQTT broker and for the weather station data to be recieved in a loop by my program. For this, I will use the client.loop\_start() and client.loop\_end() methods. I will then print this data in the python terminal.

```python
#Defining on_connect callback
def on_connect(client, userdata, flags, rc):
        if rc == 0:
            print("Connected to MQTT Broker!")
            #Subscribes to MQTT broker
            client.subscribe("weather/station/data")
        else:
            #Pints in the terminal that it failed to connect and shows the error code it recieved
            print("Failed to connect, return code: "+ rc)
            
# Setting up connection with the MQTT broker


# Defines on_message callback
def on_message(client, userdata, message):
    weatherData = (message.payload).decode()
    print ("Message received: "  + str(weatherData))

    

    # Upload data to database
    collection.insert_one(convertedWeatherData)

# Defines on_subscribe callback
def on_subscribe(client, userdata, mid, granted_qos):
     print("Subscribed")

# Defines on_connect_fail callback
def on_connect_fail(stuff):
     print("Failed")


# Paho MQTT library
import paho.mqtt.client as mqtt

#Assigns broker and client
myBroker = "public.mqtthq.com"
client = mqtt.Client("Python")

# Calls callback functions
client.on_connect = on_connect
client.on_message = on_message
client.on_subscribe = on_subscribe
client.on_connect_fail = on_connect_fail

client.connect(myBroker, 1883) #Connect to broker

client.loop_forever() # Program loop repeats forever
```

<figure><img src="../.gitbook/assets/Screenshot 2023-06-26 at 22.49.01.png" alt=""><figcaption><p>Output from terminal</p></figcaption></figure>

#### Uploading weather data to the database

After running the python program, I succesfully connected to the MQTT broker and subscribed. I then published sample data from my weather station to the MQTT broker, which the program recieved and printed in the terminal. However, I wasn't able to upload this data to mongoDB. After looking at this error more closely, I realised it was caused by the weatherData being the incorrect type. MongoDB accepts documents in the format of dictionary or bson, but the MQTT data was plain text. To convert the data into the correct format, I used the following lines of code.

```python
# Use ast to cast string to dictionary type
import ast

weatherData = str((message.payload).decode())
print ("Message received: "  + weatherData)

#convert string to dictionary
convertedWeatherData = ast.literal_eval(weatherData)

# Upload data to database
collection.insert_one(convertedWeatherData)
```

After making these changes, I ran the python program again and sucessfully recieved the following outputs in the terminal.

<figure><img src="../.gitbook/assets/Screenshot 2023-06-27 at 09.52.02.png" alt=""><figcaption></figcaption></figure>

The data was then recorded in my database. The test has now passed

<figure><img src="../.gitbook/assets/Screenshot 2023-06-27 at 09.54.27.png" alt=""><figcaption><p>Passed test</p></figcaption></figure>

### 2.4

In this final section, I will try to improve the functionality of my weather station by processing all weather station data before it enters the database. Thinking ahead, I anticipate that any inaccurate and incorrect sensor readings could cause issues when tracking trends in weather data over time. Therefore, in this program I am going to adapt my program so that it identifies any anomalies, preventing future errors.

## Outcome

### Testing

| Test | Instructions | What I expected | What actually happens | Pass/Fail |
| ---- | ------------ | --------------- | --------------------- | --------- |
| 1    |              |                 |                       |           |
| 2    |              |                 |                       |           |
| 3    |              |                 |                       |           |

### Challenges

### Evidence
