# 2.2.4 Cycle 4: Displaying and Monitoring Weather Conditions

## Design

In previous sections, I have designed a weather station to take readings from the environment, which then uploads to a database. These weather readings are then accessed by a user interface, which are displayed in the history section of the app.&#x20;

In this cycle, I am going to use this data to monitor weather conditions. The app will display current weather conditions, including temperature, pressure and humidity. Data can also be used to show the trends in conditions, in the form of a graph.

### Objectives

* [x] Display current readings for weather conditions on the user interface
* [x] Monitor weather conditions over time in the form of graphs
* [ ] Display other basic information on the user interface

### Usability Features

I need to ensure that any data displayed visually on my user interface is effective and engaging. Data must be presented in a way that is meaningful to the user, such as graphs and tables. The user interface will also need to be error tolerant, and be able to deal with missing data readings.

### Tests I need to conduct

| ID  | Test                                                                                                                                                     | Description                                                                                                                                                                                                | Pass Criteria                                                                                                                                                                                                         |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 4.1 | Automatically updating the user interface                                                                                                                | In this part, I will focus on adapting my react app to update its components at regular intervals (e.g. 30 seconds).                                                                                       | The page history should update with new readings within 30 seconds of them being recieved by the database.                                                                                                            |
| 4.2 | Display current readings                                                                                                                                 | This section will focus on displaying the most recent readings collected by the weather station on the user interface.                                                                                     | Readings should be displayed in a clear and visual way. Includes temperature, humidity, air pressure, dust concentration, altitude, light and sound.                                                                  |
| 4.3 | Visually display trends in data, e.g. graphs and tables.                                                                                                 | This part of the cycle will focus on producing a variety of graphs to allow the user to visually monitor changes in weather conditions over time.                                                          | Data will be presented in the form of line graphs, area graphs and bar charts. The graph should be easily visible, and responsive to multiple screen sizes. The scale should also change based on the data collected. |
| 4.4 | Display any other basic information, such as the time since the last reading and the time the weather station was first activated on the user interface. | This section will involve altering the "About Your Weather Station" page to contain information such as whether connection to the weather station has been successful and when the last reading was taken. | Use data to display a connection status, when data was last recieved and when the weather station was first activated.                                                                                                |

## Data structures

| Structure Name | Structure Type | Description |
| -------------- | -------------- | ----------- |
|                |                |             |
|                |                |             |
|                |                |             |

## Development

### 4.1

In this part of the cycle I am going to design a program that displays the most recent weather readings stored on the database. However, first I need to ensure the data the user interface displays is updated regularly. Currently, the node.js back-end connects to mongoDB once, and waits for a request from the front-end. In order to keep this data accurate, the app must update at regular intervals, and the data should be retrieved for the database after every request. Firstly, I altered the server.js file to wait for a request from the front-end.

```javascript
//Server listens for requests on port 8000
app.listen(8000, () => {
    console.log(`Server is running on port 8000.`);
  });

// Access database module
async function getDatabaseReadings(){

    var myData = await database
    console.log(myData);

    return myData
}

async function collectData(){

    app.get('/weatherData', (req, res) =>{

        //Responds once data has been recieved
        myData = getDatabaseReadings().then(function(myData){
            res.json({ weatherData: myData})
        })
        
    });
}

collectData();
```

<figure><img src="../.gitbook/assets/Screenshot 2023-08-04 at 18.55.35.png" alt="" width="344"><figcaption></figcaption></figure>

As expected, the server connected to mongoDB without requesting any data. After refreshing the app, the database sent a request to the database, printing the data in the terminal as shown below. The weather data was then displayed on the user interface.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-04 at 18.58.45.png" alt="" width="563"><figcaption></figcaption></figure>

However, once the database had been updated with new weather data, the back-end did not retrieve the new data from mongoDB, and was therefore not displayed on the app. This would mean I couldn't display current conditions without restarting the server each time. To resolve this, I adapted my database.js module to export the function to collect data from the database itself, instead of just the data values. This meant that new data was collected after every request.&#x20;

```javascript
//Added to database.js file
module.exports = {run}

//Added to server.js file
var myData = await database.run()
```

As expected, this allowed new data to be displayed on the react app without requiring the back-end to restart. However, after refreshing the app again, I recieved the following error.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-07 at 10.48.09.png" alt="" width="563"><figcaption></figcaption></figure>

After going through and debugging my code, I realised that the cause of this error was due to a schema repeatedly being defined every time the run() function is called. I removed the schema from the function so that it would instead only be run once when the module is exported. This resolved the issue and allowed me to refresh the app multiple times without error. This test has therefore passed.

The next step is to ensure that the front-end app does not need to be manually refreshed to recieve the most recent weather conditions. Instead, it should automatically update its components. To do this, I used the setInterval() method to get the weather data every 30 seconds.&#x20;

```javascript
useEffect(() => {
        //Calls update function at 30 second intervals
        const interval = setInterval(()=>{
            update()
        },30000)
        return()=>clearInterval(interval)
    }, [])
```

To test this, I set up the weather station program on the particle argon and ran the python mqtt program to collect data from the environment to see whether the history page of the user interface would update within 30 seconds of weather data being published to the database. The results of this can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 11.17.02.png" alt="" width="563"><figcaption></figcaption></figure>

As expected, the weather history page updated itself without refreshing the page or restarting the backend. Therefore, this test has now passed.

### 4.2

Now that the history page of the user interface automatically refreshes its data at regular intervals, the next stage is to display readings such as temperature, humidity and pressure on the user interface.

#### Temperature Readings and Update Message

To display temperature readings on the user interface, I added the code below to the MainDisplay component in my react app.&#x20;

````javascript
//Imports useState and useEffect
import React, { useState, useEffect } from "react";

const MainDisplay = () => {

    //Assigns values outside tags so that they can be changed later
    const title = "Your Weather Station";
    
    //Sets weather condition to a value
    var weatherConditions = "Sunny"
    
    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
            const data = await res.json();
            setMessage(data);  
          })
    }
    //Connects to backend
    const [message, setMessage] = useState(""); 
    
        
    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])

    return(
        <div className="mainDisplay">
            
            <div className="displayedConditions">
                <h1>{title}</h1>
                <div className="timestampHome"> The last weather update: {message?.weatherData?.slice(0, 1).map((item, idx) => {
                        return (
                            <div key={idx} >
                                {new Date(item.timestamp*1000).toLocaleDateString()}&nbsp;at&nbsp;{new Date(item.timestamp*1000).toLocaleTimeString()}                                
                            </div>
                        )
                    })}</div>
                <br></br>
                <div className="mainDisplayContent">
                    
                    <div>
                    { message?.weatherData?.slice(0, 1).map((item, idx) => {
                        return (
                            <div key={idx} className="temperature">
                                <div>
                                    {item.temp}°
                                </div>
                                
                            </div>
                        )
                    })}
                    </div>
                    </div>
            </div>

            <div className="weatherConditions">
                <p>{weatherConditions}</p>
            </div>
        </div>
    );
}
export default MainDisplay;

````

<figure><img src="../.gitbook/assets/Screenshot 2023-08-13 at 11.48.12.png" alt="" width="563"><figcaption></figcaption></figure>

As expected, the most recent temperature reading and the time the reading was taken was displayed on the home page.

#### Air Quality

Next, I am going to display the current air quality on the user interface. I started by displaying the basic reading (e.g. fresh air, low polution, danger).

```javascript

const AirQuality = () =>{
    //Maps out the most recent air quality reading
    return(
        <div>
            <div className="airQuality"> Current air quality: {message?.weatherData?.slice(0, 1).map((item, idx) => {
            return (
                <div key={idx} >
                    {item.airQual}                                
                </div>
            )
            })}
            </div>
            
        </div>
        
       
    )
}

export default AirQuality
```

Adding the code above to the AirQuality component allowed me to display the most recent air quality reading.&#x20;

<figure><img src="../.gitbook/assets/Screenshot 2023-08-13 at 12.11.51.png" alt="" width="187"><figcaption></figcaption></figure>

As mentioned in [1.4a Features of the Proposed Solution](../analysis/1.4a-features-of-the-proposed-solution.md#sensors), another way of presenting air quality data is on an index, like a speedometer. To do this, I used the React Speedometer Library. I then programmed the speedometer to move from green to red, based on the air quality readings. The code for this can be seen below.

```javascript
function calcQualityMetric(quality) {
        let qual;
        //Assigns air quality value to each possible outcome
        switch (quality) {
            case 'Fresh Air':
                qual = 125 ;
                break;
            case 'Low Pollution':
                qual=375
            case 'High Pollution':
                qual = 625
            case 'Dangerous Level':
                qual = 750
            default:
                qual = 0; 
        }
        return qual;
    }


return(
    <div>
        <div className="airQuality"> {message?.weatherData?.slice(0, 1).map((item, idx) => {
        return (
            <div key={idx} >
                <ReactSpeedometer
                    //Separates speedometer into 4 sections without labels
                    segments={4}
                    maxSegmentLabels={0}
                    
                    //Sets the format of the speedometer
                    textColor="black"
                    startColor="green"
                    endColor="red"
                    needleColor="darkblue"
                    
                    //Displays current air quality text
                    currentValueText={"Air Quality: " + item.airQual}
                    
                    //Sets size and width of speedometer and text
                    valueTextFontSize="20px"
                    ringWidth={47}
                    height={190}
                    needleHeightRatio={0.7}
    
                    
                    //Assigns speedometer position value, calling calcQualityMetric function 
                    value={calcQualityMetric(item.airQual)}
                    />                            
            </div>)
        })}</div>       
        </div>
    )
```

As shown below, by displaying air quality using a speedometer, it clearly shows the weather readings in a user-friendly format.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-13 at 14.11.35.png" alt="" width="498"><figcaption></figcaption></figure>

#### Dust Concentration, Air Pressure and Altitude

In this next section, I am going to display Dust, Air Pressure and Altitude Readings on the user interface. I started by adding the dust component, acting as a template for the other sections. This can be seen in the code below.

````javascript
//Import useState and useEffect
import React, { useState, useEffect } from "react";

const DustConc = () =>{

    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
        
      })
    }

    //Connects to backend
    const [message, setMessage] = useState(""); 

    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])

    
    return(
        <div>
            <div className="dustConc"> {message?.weatherData?.slice(0, 1).map((item, idx) => {
            return (
                
                <div className="dustContainer"key={idx} >
                    <div className="dustVal">
                        <div className="dustContents">
                            <div className="dustText">Dust Concentration</div>
                            {item.dust_conc}
                            <div className="dustText">pcs/L</div> 
                        </div>
                        
                    </div>                      
                </div>
            )})}
            </div>         
        </div>
    )
}
export default DustConc
````

I decided to include the units for dust concentration in the display. I placed the data in a circle-shaped div.  Using a similar program, I then set up the Air Pressure and Altitude display. An example of this can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-13 at 15.52.32.png" alt="" width="170"><figcaption></figcaption></figure>

#### Progress Bar - Humidity, Light and Sound

Unlike the other data readings, humidity, light and sound have a maximum possible value. Therefore, I decided to implement a progress bar into the UI to visually represent proportions of data. I started by adding the following code to the humidity component, using the React Circular Progress Bar Library.

````javascript
//Import useState and useEffect
import React, { useState, useEffect } from "react"
import { CircularProgressbarWithChildren, buildStyles } from 'react-circular-progressbar';
import "react-circular-progressbar/dist/styles.css";



const Humidity = () =>{

    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
        
      })
    }

    //Connects to backend
    const [message, setMessage] = useState(""); 

    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])

    
    return(
        <div className="dataCircle lower">
            <div className="humidity"> {message?.weatherData?.slice(0, 1).map((item, idx) => {
            return (
                
                <div style={{ width: 120, height: 120 }} key={idx} >
                    <CircularProgressbarWithChildren 
                    value={parseInt(item.humidity)}  
                    styles={buildStyles({
                        strokeLinecap: 'butt',
                        textSize: '20px',
                        pathTransitionDuration: 0.5,
                        pathColor: `#306193`,
                        textColor: 'black',
                        trailColor: '#d6d6d6',
                        
                        
                      })}
                    >
                        <div className="dataText">Humidity
                        </div><div className="progressBarText">{item.humidity}%</div></CircularProgressbarWithChildren>              
                </div>
                
            )
            })}
            </div>
            
            
            
        </div>
        
       
    )
}

export default Humidity
````

As expected, this produced a progress bar with automatically refreshes itself when it recieves new data.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 00.06.23.png" alt="" width="144"><figcaption></figcaption></figure>

Overall, in this section, I have displayed current weather readings on the user interface visually. This can be seen below. This test has now passed.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 10.39.41.png" alt="" width="563"><figcaption></figcaption></figure>

### 4.3

Previously, I have designed a program that displays current readings on the user interface. In this section, I am going to visually show the trends in weather data, allowing the user to monitor their environment more closely. This will be in the form of line graphs, area charts and bar charts, using the react charts 2 library.

#### Line Graph - Today's Trends in Temperature

The first graph I program is a line graph, representing trends in temperature over the last 24h (approx).

````javascript
import React, { useState, useEffect } from "react";
import { Line } from 'react-chartjs-2';
import {
    Chart as ChartJS,
    LineElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Legend
} from 'chart.js';

ChartJS.register(
    LineElement,
    CategoryScale,
    LinearScale,
    PointElement,
    Title,
    Legend
)
const TempGraph = () => {
    
    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
        
      })
    }

    //Connects to backend
    const [message, setMessage] = useState(""); 

    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])
    let timestamp = message?.weatherData?.slice(0,24).map(({timestamp})=>new Date(timestamp * 1000).toLocaleTimeString())
    let temp = message?.weatherData?.slice(0,24).map(({temp})=>temp)
    
    const graphData = {
        
        labels: timestamp,
        datasets: [{
            label: "Temperature",
            data: temp,
            backgroundColor: 'orange',
            borderColor: 'orange',
            pointBorderColor: 'orange',
            tension: 0.4,
    
        }]
    }
    
    const options = {
        
        maintainAspectRatio: false,
        
        plugins:{
            maintainAspectRatio: false,
            legend: {
                
                labels: {
                    boxwidth:0,
                }
            },
            title:{
                display: true,
                text: "Today's Trends in Temperature"
            }
        },
        scales: {
            y:{
                min: Math.min.apply(Math,temp) -1,
                max: Math.max.apply(Math,temp) +1
            }
        }
    }
    return (        
        <div className="tempGraph">
            <div className="graphData">
                <Line
                    data={graphData}
                    options={options}
                    className="graphContent"

                ></Line>
            </div>
        </div>
    )
}

export default TempGraph
````

While the code successfuly produced a graph containing the 24 most recent readings of temperature, I realised that since in the database data is sorted from most recent to oldest, all the readings where in the reverse order.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 00.12.25.png" alt="" width="295"><figcaption></figcaption></figure>

To resolve this, I used the .reverse(method) to change the order of the time and temperature values. This fixed the issue, as can be seen below.

```javascript
let timestamp = message?.weatherData?.slice(0,24).map(({timestamp})=>new Date(timestamp * 1000).toLocaleTimeString()).reverse()
let temp = message?.weatherData?.slice(0,24).map(({temp})=>temp).reverse()
```

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 00.12.35.png" alt="" width="287"><figcaption></figcaption></figure>

#### Bar Chart - Light and Sound

Since both light and sound are measured on the same scale, they can be directly compared. To do this, I decided to use a bar chart to compare the 14 most recent readings. Just as with the temperature graph, I had to use the .reverse() method to ensure the data is displayed in the correct order.

````javascript
import React, { useState, useEffect } from "react";
import { Bar } from 'react-chartjs-2';
import {
    Chart as ChartJS,
    BarElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Tooltip,
    Legend
} from 'chart.js';

ChartJS.register(
    BarElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Tooltip,
    Legend
)
const LightSoundChart = () => {
    
    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
        
      })
    }

    //Connects to backend
    const [message, setMessage] = useState(""); 

    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])
    let timestamp = message?.weatherData?.slice(0,14).map(({timestamp})=>new Date(timestamp * 1000).toLocaleDateString()).reverse()
    let sound = message?.weatherData?.slice(0,14).map(({sound})=>sound).reverse()
    let light = message?.weatherData?.slice(0,14).map(({light})=>light).reverse()
    
    
    const graphData = {
        labels: timestamp,
        datasets: [
            {
                label: "Sound",
                data: sound,
                backgroundColor: '#385fc2',
                borderColor: '#385fc2',
                borderWidth: 1
            },
            {
                label: "Light",
                data: light,
                backgroundColor: '#45a0a9',
                borderColor: '#45a0a9',
                borderWidth: 1
            },
           
        ]
    }

    const options = {
        maintainAspectRatio: false,
        plugins:{
            maintainAspectRatio: false,
            title:{
                display: true,
                text: "Light and Sound"
            }
        },
        scales: {
            y:{
                min: 0,
                max: 3000
            }
        }
    }
    
    
    return (        
        <div className="lightSoundGraph">
            <div className="lightSoundgraphData">
                <Bar
                    data={graphData}
                    options={options}
                    className="lightSoundgraphContent"

                ></Bar>
            </div>
        </div>
    )
}

export default LightSoundChart
````

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 00.23.12.png" alt="" width="308"><figcaption></figcaption></figure>

#### Area Graph - Humidity

The area graph can be used to show the proportion of a value on an axis, making is suitable for visualising % humidity.&#x20;

````javascript
import React, { useState, useEffect } from "react";
import { Line } from 'react-chartjs-2';
import {
    Chart as ChartJS,
    BarElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Tooltip,
    Filler,
    Legend
} from 'chart.js';

ChartJS.register(
    BarElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Tooltip,
    Filler,
    Legend
)
const HumidityGraph = () => {
    
    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
        
      })
    }

    //Connects to backend
    const [message, setMessage] = useState(""); 

    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])
    let timestamp = message?.weatherData?.slice(0,14).map(({timestamp})=>new Date(timestamp * 1000).toLocaleDateString()).reverse()
    let humidity = message?.weatherData?.slice(0,14).map(({humidity})=>humidity).reverse()
    
    
    
    
    const graphData = {
        labels: timestamp,
        datasets: [
            {
                fill: true,
                label: "% Humidity",
                data: humidity,
                borderColor: 'rgb(53, 162, 235)',
                backgroundColor: 'rgba(53, 162, 235, 0.5)',
                
            },
            
           
        ]
    }

    const options = {
        maintainAspectRatio: false,
        plugins:{
            maintainAspectRatio: false,
            title:{
                display: true,
                text: "Humidity Trends"
            },
            legend: {
                position: 'top'
            }
        },
        scales: {
            y:{
                min: 0,
                max: 100
            }
        }
    }
    
    
    return (        
        <div className="humidityGraph">
            <div className="humidityContent">
                <Line
                    data={graphData}
                    options={options}
                    

                ></Line>
            </div>
        </div>
    )
}

export default HumidityGraph
````

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 00.26.19.png" alt="" width="276"><figcaption></figcaption></figure>

#### Line Graph - Dust Concentration

The final graph I will build in this section is dust concentration.

````javascript
import React, { useState, useEffect } from "react";
import { Line } from 'react-chartjs-2';
import {
    Chart as ChartJS,
    BarElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Tooltip,
    Filler,
    Legend
} from 'chart.js';

ChartJS.register(
    BarElement,
    CategoryScale, //x axis
    LinearScale, //y axis
    PointElement,
    Title,
    Tooltip,
    Filler,
    Legend
)
const DustGraph = () => {
    
    // Fetches data from the backend on port 8000
    async function update(){
        await fetch("http://localhost:8000/weatherData")  
        .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
        
      })
    }

    //Connects to backend
    const [message, setMessage] = useState(""); 

    useEffect(() => {
        //Repeatedly calls the update() function at 30 second ```javascript
        update()
        const interval = setInterval(()=>{
            update()
        },30000)
        //Clears the interval
        return()=>clearInterval(interval)
    }, [])
    let timestamp = message?.weatherData?.slice(0,14).map(({timestamp})=>new Date(timestamp * 1000).toLocaleTimeString()).reverse()
    let dust = message?.weatherData?.slice(0,14).map(({dust_conc})=>dust_conc).reverse()
    
    
    
    
    const graphData = {
        labels: timestamp,
        datasets: [
            {
                fill: true,
                label: "pcs/L dust",
                data: dust,
                borderColor: '#c25838',
                backgroundColor: 'rgb(219, 155, 136, 0.5)',
                
            },
            
           
        ]
    }

    const options = {
        maintainAspectRatio: false,
        plugins:{
            maintainAspectRatio: false,
            title:{
                display: true,
                text: "Dust Readings"
            },
            legend: {
                position: 'top'
            }
        },
        scales: {
            y:{
                min: 0,
                max: Math.max.apply(Math,dust) +200
            }
        }
    }
    
    
    return (        
        <div className="dustGraph">
            <div className="dustContent">
                <Line
                    data={graphData}
                    options={options}
                    

                ></Line>
            </div>
        </div>
    )
}

export default DustGraph
````

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 00.28.28.png" alt="" width="505"><figcaption></figcaption></figure>

#### Adjusting Graph Scales

Now that the user interface displays several visual graphs and charts, the final step in this section is to ensure that they are correctly formatted. This involves making each of the graphs responsive to different screen sizes and adjusting the scale on the axis so that it is large enough to display all the collected data. After modifying the css to work with multiple screen sizes, I added the following code to the options object of each graph to change the scale based on the amount of data.

```javascript
// Today's Trends in Temperature Graph
const options = {
    //Disables default settings for graph size
    maintainAspectRatio: false,
    plugins:{
        //Graph label
        legend: {
            labels: {
                boxwidth:0,
            }
        },
        title:{
            //Graph title
            display: true,
            text: "Today's Trends in Temperature"
        }
    },
    //Scale changes to fit in the full data range
    scales: {
        y:{
            min: Math.min.apply(Math,temp) -1,
            max: Math.max.apply(Math,temp) +1
        }
    }
}

//Humidity Trends
const options = {
    maintainAspectRatio: false,
    plugins:{
        title:{
            display: true,
            text: "Humidity Trends"
        },
        legend: {
            position: 'top'
        }
    },
    scales: {
        y:{
            //As humidity is measured as a percentage, the scale will always range between 0 and 100
            min: 0,
            max: 100
        }
    }
}

//Dust Readings
const options = {
    maintainAspectRatio: false,
    plugins:{
        maintainAspectRatio: false,
        title:{
            display: true,
            text: "Dust Readings"
        },
        legend: {
            position: 'top'
        }
    },
    scales: {
        //Sets scale to 10% above the maximum value
        y:{
            min: 0,
            max: Math.max.apply(Math,dust) *1.2
        }
    }
}

//Light and Sound Readings
const options = {
    maintainAspectRatio: false,
    plugins:{
        maintainAspectRatio: false,
        title:{
            display: true,
            text: "Light and Sound"
        }
    },
    //Light and Sound Readings usually range between 0 and 3600
    scales: {
        y:{
            min: 0,
            max: 3600,
        }
    }
}
```

The overall result on the user interface can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 10.37.13.png" alt="" width="563"><figcaption><p>Large Screen - Double Column View</p></figcaption></figure>

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 10.26.05.png" alt="" width="375"><figcaption><p>Small Screen - Single Column View</p></figcaption></figure>

### 4.4

In this final section of cycle 4, I am going to improve the functionality of the user interface by improving the about and help pages.&#x20;

### About Page

As well as containing basic information about how the weather station works, the about page will display 3 pieces of data; a connection status, when data was last recieved, and when the weather station was first activated.&#x20;

#### Connection Status

The connection status will determine whether the weather station is working correctly and connected to the database. If there is weather data displayed within 2 hours of the current time, the connection status will be ACTIVE. However, if it has been longer than 2 hours since the last reading, this could indicate that the weather station has run out of battery or is unable to connect to the internet, so the status will be OFFLINE. This can be seen in the code below.

```javascript
//The values of these variables will change depending on the connection with the weather station
let connection_status

//Timestamp of most recent message
let dataTimestamp = message?.weatherData?.slice(0,1).map(({timestamp})=>timestamp*1000).reverse();

//Current timestamp
let nowTimestamp = Date.now()

//Checks whether last reading was taken within 2 hours
if ((nowTimestamp-dataTimestamp)<=7200000){
    connection_status = "ACTIVE";
}
else {
    connection_status = "OFFLINE";
}

return (
    <p>Connection Status - <b>{connection_status}</b></p> 
)
```

As expected, since the reading was taken less than 2 hours ago, the connection status was correctly displayed as active.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 12.54.50.png" alt="" width="279"><figcaption></figcaption></figure>

After 2 hours with the weather station turned off, the connection status changed to OFFLINE, showing that this feature is working correctly.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 13.14.02.png" alt="" width="282"><figcaption></figcaption></figure>

#### Weather data last recieved

This component will convert the timestamp of the most recent reading to a date and time, giving the user an indication of when weather data was last collected from the weather station.

```javascript
<div className="aboutInfoContent" ><div className="aboutLog"><p>Weather data last recieved - <b>{message?.weatherData?.slice(0,1).map((item, idx)=>{
    return (
        <div key={idx} > 
        {new Date(item.timestamp*1000).toLocaleDateString()}&nbsp;at&nbsp;{new Date(item.timestamp*1000).toLocaleTimeString()}
        </div>
    )
    })}</b></p> 
</div></div>
```

As expected, this displayed the date of the most recent reading, which can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 13.25.20.png" alt="" width="269"><figcaption></figcaption></figure>

#### Weather station first activated

The final reading I will display on the about page is when the weather station was first activated. This is similar to the previous section but this time I need to include the .reverse() method.

```javascript
<div className="aboutInfoContent" ><div className="aboutLog"><p>Weather data last recieved - <b>{message?.weatherData?reverse().slice(0,1).map((item, idx)=>
    return (
        <div key={idx} > 
        {new Date(item.timestamp*1000).toLocaleDateString()}&nbsp;at&nbsp;{new Date(item.timestamp*1000).toLocaleTimeString()}
        </div>
    )
    })}</b></p> 
</div></div>
```

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 13.32.16.png" alt="" width="287"><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/Screenshot 2023-08-14 at 13.34.19.png" alt="" width="563"><figcaption></figcaption></figure>

### User Instructions

### Outcome



### Testing

| Test | Instructions | What I expect | What actually happened | Pass/Fail |
| ---- | ------------ | ------------- | ---------------------- | --------- |
|      |              |               |                        |           |
|      |              |               |                        |           |
|      |              |               |                        |           |

### Challenges



### Evidence
