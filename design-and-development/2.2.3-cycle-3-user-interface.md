# 2.2.3 Cycle 3: User Interface

## Design

Now that I have programed the foundations of my solution, data collection and storage, in this cycle I will begin developing the user interface for my weather monitoring application. Once this stage is complete, I will then be able to move on to displaying the data I have collected, monitoring trends over time, and weather prediction.

In this cycle I will design and develop a basic web app that is capable of displaying weather data.&#x20;

### Objectives

* [x] Setup a basic web app using react js
* [x] Add content to web app
* [x] Format web app
* [ ] Improve usability and test

### Usability Features

In order to meet the needs of the stakeholder, the user interface for my weather app needs to provide the best user experience possible. It must be easy to use and navigate, and should require a minimal input from the user to work correctly. It must be effective at visually presenting any weather data the user wants to access, and must also be able to connect to mongoDB to display data.

### Tests I need to conduct

Although I am eventually going to need to incorporate live data collected from my weather station and documents stored in my database, in this cycle I am going to focus on building a basic user interface that meets the usability requirements of a stakeholder.

| ID  | Task                                      | Description                                                                                                                                                                                                      | Pass Criteria                                                                                                                                                              |
| --- | ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 3.1 | Build a basic weather station application | In this section, I will setup a basic web app using react.js as a front-end and node.js as a backend. This will be the foundation of my weather app. The app must also be able to communicate with the database. | I should be able to display text from both the front-end and back-end in the app. I should then be able to connect to mongoDB using node and display this data on the app. |
| 3.2 | Basic user interface                      | In this part of the cycle, I use my user interface design, to build a template for my weather app.                                                                                                               | The user interface should be able to respond to the size of the screen and be accessible from a variety of devices.                                                        |
| 3.3 | App functionality                         | In this section I will focus on adding essential components to my app, including the menu and settings tabs.                                                                                                     | The stakeholder should be able to navigate through to different sections of the app easily.                                                                                |
| 3.4 | Improving usability of the app            | In the final section of this cycle, I will add other components to the app to improve usability, including graphs, diagrams, and including instructions that help the user understand how to use the app         |                                                                                                                                                                            |

### Data Structures

| Structure name | Structure type | Description |
| -------------- | -------------- | ----------- |
|                |                |             |
|                |                |             |
|                |                |             |

### Development

### 3.1

In the first section of this cycle, I am going to build a basic app. I will use react js as a front-end and node js as a back-end. While the front-end will be used to make my user interface, the back-end will be used to communicate with my database and collect the weather data to be displayed on the app. To do this, I will create a request for both the server and main client and display it on a web browser. Then, I will display some of the data collected by the weather station on my app.

#### Setting up a react js app

In this section, I am going to setup the front-end of my app and display text on the app. Firstly, I created a react app and added the following code to the app.js file.

```javascript
function App() {
    return (
        <div className="App">
            <div className="MainContent">
                <h1>Welcome to my weather station app!</h1>
                <p> This is where the data from your weather station will be displayed.</p>
            </div>
        </div>
    )
}
```

As expected, the app displayed the text in the react app.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-04 at 10.23.36.png" alt=""><figcaption></figcaption></figure>

#### Using node js as a back-end

The next stage of my project is to make a node.js back-end which can communicate with the main react app. The react app should be able to access and display data from the node backend. I added to the code below to the server.js file. I used express to create a web server, which I will run on port 8000.

```javascript
// Import libraries
const express = require('express');

// Create express application
const app = express();
const cors = require("cors");

app.use(cors());
app.use(express.json());

// Creates an endpoint for the route /weatherData
app.get('/message', (req, res) =>{
    res.json({ message: "The current temperature is 25 degrees!"})
});

// Server listens for requests on port 8000
app.listen(8000, () => {
    console.log(`Server is running on port 8000.`);
});
```

As expected, this printed the following in the terminal.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-04 at 10.33.52.png" alt=""><figcaption></figcaption></figure>

The message was also displayed in the web server.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-04 at 10.35.31.png" alt=""><figcaption></figcaption></figure>

Now that I have created both a back-end and front-end, I need to connect both aspects of my app together. I added the code below to the app.js program to connect to the back-end and display the message on the react app.

```javascript
// Includes react module
import React, { useState, useEffect } from "react";

function App() {
  const [message, setMessage] = useState("");

  useEffect(() => {
    fetch("http://localhost:8000/message")
      .then((res) => res.json())
      .then((data) => setMessage(data.message));
  }, []);
  

  return (

    <div className="App">

      <div className="MainContent">
        <h1>Welcome to my weather station app!</h1>
        <p> This is where the data from your weather station will be displayed.</p>
        <h1>{message}</h1>
      </div>
    </div>
  );
}

export default App
```

<figure><img src="../.gitbook/assets/Screenshot 2023-07-04 at 10.55.55.png" alt=""><figcaption></figcaption></figure>

The react app was sucessfully able to acess the back-end and display the text on the app as expected. This will be useful later in this cycle when I need to access weather data readings from mongoDB.

#### Collecting data from mongoDB

The final aspect of setting up my app is connecting it to mongoDB, and displaying the data collected on my app.  Firstly, I used the following code to connect to mongoDB. As expected, I recieved the message "Connected to MongoDB" without any errors in the terminal.

```javascript
//Connect to mongoDB
const mongoose = require("mongoose");

const uri = "mongodb+srv://lrosesmith23:<password>@mystation.uoil79h.mongodb.net/?retryWrites=true&w=majority";

connect();

//Function to connect to mongoDB and log results in the console
async function connect(){
    try {
        //Connects to mongoDB
        await mongoose.connect(uri);
        console.log("Connected to MongoDB");
    } catch (error){
        console.error(error);
    }
}
```

<figure><img src="../.gitbook/assets/Screenshot 2023-07-05 at 10.31.02.png" alt=""><figcaption></figcaption></figure>

I added the following lines of code to my program to find and retrieve all the data on weather readings from mongoDB.

```javascript
//Defines the structure and properties of the document
const myDataSchema = new Schema({
    timestamp: Number,
    temp: Number,
    humidity: Number,
    pressure: Number,
    altitude: Number,
    airQual: String,
    lpo_val: Number,
    dust_ratio: Number,
    dust_conc: Number,
    light: Number,
    sound: Number
}, {collection : "weather"});

//Creates model for weather collection
var Weather = mongoose.model('weather', myDataSchema)

//Collects all data in database
var docs = await Weather.find();

//Displays data in the terminal
console.log(docs)
```

However, this resulted in an error that can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-05 at 11.55.19.png" alt=""><figcaption></figcaption></figure>

I realised that the issue was that await can only be used in a asynchronous function. After placing the code above in a seperate function, I recieved the data that can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-05 at 11.57.55.png" alt=""><figcaption></figcaption></figure>

To make it easier to manage my app back-end, I placed the database program in a seperate module. I placed the code above to a database.js module and added the following code to export the data.

```javascript
module.exports = results
```

I then added the code below to the server.js module. As before, this displayed the documents in the terminal.

```javascript
// Access database module
async function collectData(){
    var myData = await database;
    console.log(myData);
}

collectData();
```

#### Displaying weather data

The final step in this section is to connect the back-end to the react app and display it.

Program in server.js (node back-end)

<pre class="language-javascript"><code class="lang-javascript"><strong>app.get('/weatherData', (req, res) =>{
</strong><strong>    res.json({ weatherData: myData})
</strong>});
</code></pre>

This resulted in the data being displayed on "localhost:8000/weatherData".

<figure><img src="../.gitbook/assets/Screenshot 2023-07-05 at 17.37.23.png" alt=""><figcaption></figcaption></figure>

Program in App.js (react front-end)

```javascript
const [message, setMessage] = useState(""); 
useEffect(() => {
    fetch("http://localhost:8000/weatherData")  
    .then(async (res) => { 
        const data = await res.json();
        setMessage(data);
      })
  }, []);
  
//display on react app
<div className="App">
    <h1>Welcome to my weather station app!</h1>
    <p> This is where the data from your weather station will be displayed.</p>
    
    //Displays raw weather data
    <pre>{JSON.stringify(message, null, 2)}</pre>
</div>
```

<figure><img src="../.gitbook/assets/Screenshot 2023-07-06 at 09.17.45.png" alt=""><figcaption></figcaption></figure>

The image above shows the raw weather data from the database being displayed on my app. This test has now passed.

### 3.2

Before I could start adding components to my react app, I needed to design an outline for the user interface. My graphical user interface must be easy for the user to navigate, and include up-to-date information. However, in this section I am going to use some sample data to simulate what my weather application will look like when building the user interface.

### User interface design:

<figure><img src="../.gitbook/assets/Screenshot 2023-07-06 at 18.45.21 (1).png" alt=""><figcaption></figcaption></figure>

To design my user interface, I separated all the sections out into boxes. The top box shows basic weather information, including temperature and weather conditions, as well as when the display was last updated. Below shows the separate readings from the weather station, including air quality, dust concentration, humidity, pressure, altitude, light and sound. I will also have several graphs showing recent trends in readings, allowing the stakeholder to monitor conditions in their surrounding environment. Additionally, on the right hand side I have included a section to display weather forecasting information (which I will work on in a separate cycle) and left a space for any other features I will add in future cycles. There is also a menu and settings tab which allows the user to navigate through the app easily. I have adapted the user interface above to show how it would work on a different shaped device.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-06 at 20.04.37.png" alt=""><figcaption></figcaption></figure>

Now that I have a clear plan in mind for my user interface, I am going to start building the foundations of the app.

In this part of cycle 3, I am going to focus on building up a template user interface for the app I will display weather data on. At this stage, the app will not display any data from the weather station as I am focusing on the usability and functionality of the app. I started by separating my code down into modules - app, home and menu. Within these sections, I have broken down my user interface into its separate components, including the main display, air quality and data readings.&#x20;

The code for the three basic modules in my user interface can be seen below.

```javascript
// APP - App.js

//Imports other modules
import Home from './Home';
import Menu from './Menu';

function App() {
  return (
    //The main content of my app
    <div className="App">
      <div className="content">
          //Adds other modules to webpage
          <Menu/>
          <Home/>
      </div>
    </div> 
  );
}

//Exports code to index.js
export default App;
```

```javascript
// MENU - Menu.js
const Menu = () => {
    return (
        <div className="menu">
            <p>menu</p>
        </div>
    )
}

//Exports code to be used by app.js
export default Menu;
```

```javascript
// HOME PAGE - Home.js

//Imports all the modules shown on home page
import MainDisplay from './MainDisplay';
import AirQuality from './AirQuality';
import DataReading from './DataReadings';
import WeatherPredictions from './WeatherPredictions';
import Graph from './Graph';
import AdditionalStuff from './AdditionalStuff';
import Settings from './Settings';


const Home = () => {
    
    return(
        <div className="homePage">
            
            // The app is separated into two main columns
            <div className="columns">
            
            // Left column contents
            <div className="leftcolumn">
                <MainDisplay />
                <div className="myReadings">
                    <AirQuality/>
                    <DataReading/>
                    <DataReading/>
                    <DataReading/>
                </div>
                <Graph/>
                <Graph/>
                <AdditionalStuff/>
            </div>

            // Right column contents
            <div className="right column">
                <Settings/>
                <WeatherPredictions /> 
                <div className="otherReadings">
                    <DataReading/>
                    <DataReading/>
                    <DataReading/>
                </div>
                <Graph/>
            </div>
            
            </div>
            
        </div>
    );
}

// Exports code to be used by app.js
export default Home;

```

After adding these individual modules to my app, I ran the program, resulting in the webpage shown below.&#x20;

<figure><img src="../.gitbook/assets/Screenshot 2023-07-20 at 09.27.25.png" alt=""><figcaption></figcaption></figure>

The image above shows the basic structure of my react app. Within the main display, I will show the temperature, current air conditions, and when the app was last updated. All the components in my app will be separated into two separate columns when on a wide screen, and a single longer column when on a smaller screen (as shown by my [user interface design](2.2.3-cycle-3-user-interface.md#user-interface-design)). As I was able to successfully form the foundations of my app, this test has passed.

#### Adding style to my app

The next stage to building my user interface is adding style to improve usability for the stakeholder. The code below shows my index.css file.

```css
.App {
    margin: 10px
}

.mainDisplay {
    color:rgb(1, 0, 2);
    background-color: rgb(246, 242, 242);
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-gap: 10px;
    
    padding-bottom: 20px;
    padding-left: 10px;
    
}
.mainDisplayContent {
    text-align: center;
}
.settingsButton {
    text-align: center;
    font-size: 20px;
    background-color: rgb(180, 178, 178);
}
.settings {
    margin:0px;
    padding-bottom: 10px;

}
.homePage {
    background-color: white;
}

.airQuality {
    background-color:rgb(246, 242, 242);
}

.dataReadings {
    background-color:rgb(246, 242, 242);
}

.temperature {
    min-width: 200px;
    font-size: 50px;
    padding-top: 1px;
    padding-bottom: 1px;
    background-color: rgb(180, 178, 178);
}
.rightColumn {
    margin:0
}
.weatherConditions {
    text-align: center;
    font-size: 30px;
    background-color: rgb(180, 178, 178);
    min-width: 150px;
}
.weatherPredictions {
    background-color:rgb(246, 242, 242);
    text-align: center;
    font-size: 30px;
    padding-bottom: 300px;
    margin-bottom: 10px;
    padding-top: 20px;
}


.myReadings {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    grid-gap: 10px;
    margin-top: 10px;
    text-align: center;
    
}

.airQuality {
    padding:20px;
}

.dataReadings {
    padding:20px;
}

.graph {
    background-color: rgb(246, 242, 242);
    padding: 20px;
    margin-top: 10px;
    height: 20%;

}

.additionalStuff{
    margin-top: 10px;
    background-color: rgb(246, 242, 242);
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 40px;
    padding-bottom: 40px;
}

.otherReadings {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-gap: 10px;

}

.menu {
    background-color: rgb(180, 178, 178);
    padding:1px;
    margin-bottom:10px;
    height: 124%;
    
}
```

By formatting my user interface, it will allow me to visualise the layout and the further changes that will need to be made in the future. Additionally, I will later adapt the style of my app to further improve its navigation and engagement with the user.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-20 at 09.38.25.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/Screenshot 2023-07-20 at 09.38.40.png" alt=""><figcaption></figcaption></figure>

#### Making the app responsive

Now that I have built the foundations of my user interface, the next stage is to improve its performance. So that my app is accessable by a variety of devices, I am going to use two columns when the width of the screen is over 800px. Otherwise, I will use a single column. I added the following code to index.css.

```css
/* responsive web design

Style when using a wide screen > 800px */
@media (min-width: 800px) {
    .content{
        display : grid;
        grid-template-columns: 1fr 15fr;
        grid-gap: 10px
    }
    .weatherPredictions{
        margin-top:0px;
    }
    .columns {
        display: grid;
        grid-template-columns: 2fr 1fr;
        grid-gap: 10px;
    }
    .temperature{
        margin-left: 5px;
        margin-right: 5px;
    }
    .weatherConditions{
        margin: auto;
        max-width: 5000px;
    }
    .settingsButton{
        margin-left: auto;
        padding-left: 10px;
        padding-right: 10px;
        margin-top: 0px;
    }
}

/* Style when using a small screen < 800 px */
@media (max-width: 850px) {
    .temperature {
        max-width: 200px;
        margin:auto;
    }
    .weatherConditions {
        max-width: 200px;
        margin:auto;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    .settingsButton {
        margin-left: auto;
        padding-left: 10px;
        padding-right: 10px;
        margin-top: 0px;
        
    }
    .weatherPredictions{
        margin-top: 10px;
    }
}
```

The results of this can be seen below.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-20 at 09.50.17.png" alt=""><figcaption><p>Screen width greater than 800px</p></figcaption></figure>

<figure><img src="../.gitbook/assets/Screenshot 2023-07-20 at 09.54.23.png" alt=""><figcaption><p>Screen width less than 800px</p></figcaption></figure>

By changing the width of the device screen, I was successfully able to switch between the 1 and 2 column view. However, the minimum width of the screen had to be 520px for the app to be displayed correctly. Therefore, further adjustments must be made to make it accessable to other smaller devices, such as smartphones.

To resolve this, I altered my code so that it would alter the grid layout below 520px.

````css
```css
@media (min-width: 800px) {
    .content{
        display : grid;
        grid-template-columns: 1fr 15fr;
        grid-gap: 10px
    }
    
    .weatherPredictions{
        margin-top:0px;
    }
    .columns {
        display: grid;
        grid-template-columns: 2fr 1fr;
        grid-gap: 10px;
    }
    .temperature{
        margin-left: 5px;
        margin-right: 5px;
    }
    .weatherConditions{
        margin: auto;
        max-width: 5000px;
    }
    .settingsButton{
        margin-left: auto;
        padding-left: 10px;
        padding-right: 10px;
        margin-top: 0px;
    }
    .mainDisplay{
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 10px;
    }
    .myReadings{
        display: grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        grid-gap: 10px;
    }
    .otherReadings {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-gap: 10px;
    
    }
}
@media (max-width: 850px) and (min-width: 520px) {
    .temperature {
        max-width: 200px;
        margin:auto;
    }
    .weatherConditions {
        max-width: 200px;
        
        margin:auto;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    .settingsButton {
        margin-left: auto;
        padding-left: 10px;
        padding-right: 10px;
        margin-top: 0px;
        
    }
    .weatherPredictions{
        margin-top: 10px;
    }
    .mainDisplay{
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 10px;
    }
    .myReadings {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        grid-gap: 10px;
    }
    .otherReadings {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-gap: 10px;
    
    }
}

@media (max-width: 520px) and (min-width: 360px) {
    .mainDisplay{
        padding-right:10px;
    }
    .myReadings{
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 10px;
    }
    .otherReadings {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-gap: 10px;
    
    }
}

@media (max-width:360px) {
    .mainDisplay{
        padding-right:10px;
    }
    .myReadings{
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 10px;
    }
    .otherReadings{
        margin-top: 10px;
        margin-bottom:10px;
    }
    .dataReadings{
        margin-top: 10px;
        margin-bottom:10px;
    }
    .airQuality{
        margin-top: 10px;
        margin-bottom:10px;
    }
}
```
````

According to (https://accessally.com/, 2023), the smallest smartphone screen size that is actively in use is the iphone 5, which is 320 pixels wide. Therefore, I must alter the layout to ensure that the app is usable on this device. The image below shows how the altered program allows the app to respond to the size of the screen. This test has now passed.

<figure><img src="../.gitbook/assets/Screenshot 2023-07-23 at 22.53.41.png" alt=""><figcaption></figcaption></figure>

Overall, in this section I have managed to build the template for my user interface. While the app still doesn't completely match the [original design](2.2.3-cycle-3-user-interface.md#user-interface-design), in sections [3.3](2.2.3-cycle-3-user-interface.md#3.3) and [3.4 ](2.2.3-cycle-3-user-interface.md#3.4)I will continue to develop other sections to improve functionality.

### 3.3

In this part of the cycle, I am going to adapt my app to include other sections as well as the homepage. This will include a menu containing home, user instructions and notifications, as well as settings.&#x20;

### Menu



#### Menu Tabs

#### User instructions

#### Notifications



### Settings

###

### 3.4

In the final section of this cycle, I am going to focus on improving engagement and usability. As well as making sure the app is functional, this will also include adapting the visual componenets of the app so that it is easy to navigate.

## Outcome

### Testing



| Test | Instructions | What I expect | What actually happens | Pass/Fail |
| ---- | ------------ | ------------- | --------------------- | --------- |
|      |              |               |                       |           |
|      |              |               |                       |           |
|      |              |               |                       |           |

### Challenges

### Evidence
